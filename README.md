# 🍇 멀티스레드 티켓팅 시뮬레이터 (Multi-threaded Ticketing Simulator)

이 프로젝트는 아이돌 콘서트 예매와 같은 **고동시성(High-concurrency)** 환경을 자바 멀티스레딩 기술로 구현한 시뮬레이션입니다.

**경쟁 상태(Race Condition)** 해결, **스레드 동기화**, 그리고 `wait/notify` 메커니즘을 이용한 **스레드 간 통신**을 실습하기 위해 설계되었습니다.

## 🚀 주요 기능

* **Thread-Safe 예약 시스템**: `synchronized` 블록을 사용하여 여러 사용자가 동시에 같은 좌석을 예약하려 할 때 데이터가 꼬이지 않도록 보장합니다.
* **제한 시간 대기 및 재시도 (Timed-Wait & Retry)**: 사용자는 자리가 없다고 바로 포기하지 않습니다. 특정 좌석을 최대 **3초 동안** 기다리며, 시간이 초과되면 지능적으로 다른 "포도알(빈 좌석)"을 찾아 이동합니다.
* **역동적인 취소 시나리오**: 예약에 성공한 사용자가 일정 확률로 예약을 취소합니다. 이때 `notifyAll()` 신호가 발생하여 대기 중이던 스레드들이 즉시 다시 경쟁을 시작합니다.
* **실시간 콘솔 시각화**: ANSI 색상 코드를 활용하여 좌석 현황을 실시간으로 출력합니다.
* 🍇 `[●]` : 예매 가능한 **포도알** (보라색)
* ❌ `[X]` : 이미 선택된 좌석 (회색)
* ⚠️ `[대기/취소]` : 노란색과 빨간색 로그로 실시간 상황 강조

---

## 🏗 프로젝트 아키텍처

관심사 분리(SoC)를 위해 다음과 같은 구조로 설계되었습니다:

* **`model.Seat`**: 공유 자원인 좌석 객체.
* **`manager.TicketingManager`**: **임계 영역(Critical Section)** 관리자. 예약(`reserveWithTimeout`) 및 취소(`cancelReservation`) 로직의 동기화를 제어합니다.
* **`thread.UserAction`**: `Runnable` 구현체. 사용자의 무작위 좌석 선택, 대기, 취소 행동을 정의합니다.
* **`common.ThreadUtil`**: `Thread.sleep()` 시 발생하는 예외 처리를 간소화하고 인터럽트 상태를 관리합니다.

---

## 🛠 기술 스택

* **Language**: Java 17
* **Build Tool**: Maven

---

## 📊 시뮬레이션 흐름

1. **초기화**: 메모리 내에 30개의 좌석을 생성합니다.
2. **경쟁 발생**: 30명의 사용자(Thread)가 동시에 접속하여 좌석 선점을 시도합니다.
3. **대기 및 신호**:
* 좌석이 없으면 사용자는 `WAITING` 상태로 대기합니다.
* 예약자가 취소하면 `notifyAll()` 사이렌이 울립니다.
* 잠들어 있던 스레드들이 깨어나 빈 좌석을 향해 다시 레이스를 펼칩니다.

4. **최종 리포트**: 모든 활동이 종료되면 좌석별 최종 소유주와 예약 통계를 출력합니다.

---

## 중요 포인트: “좌석 선점”은 wait 중이 아니라, 깨어난 뒤에 일어납니다

- A가 `wait()`로 잠든 동안에는 A가 선점할 수 없습니다.
- 다른 스레드들도 해당 좌석을 “자동으로” 선점하는 것이 아닙니다.
- 좌석 선점은 **어떤 스레드가 다시 `reserveWithTimeout()`에 진입하여 조건을 통과한 뒤**에 발생합니다.

좌석을 선점하려면 결국 누군가가 아래 과정을 수행해야 합니다.

1. `reserveWithTimeout()`로 들어갑니다.  
2. `if (!targetSeat.isReserved())`를 통과합니다.  
3. `targetSeat.setReserved(userName)`를 실행합니다.

이 “선점(setReserved)”은 **항상 `synchronized`(락을 잡은 상태)** 에서만 이루어집니다.

따라서 선점은 보통 아래 시퀀스로 발생합니다.

1. 누군가가 취소하여 좌석이 비게 됩니다. (`cancelReservation`)  
2. `notifyAll()`로 대기자들이 깨어납니다.  
3. 깨어난 스레드들(그리고 새로 들어온 스레드들)이 **락을 다시 잡기 위해 경쟁합니다.**  
4. **락을 먼저 잡은 스레드가** “비었는지 재검사”한 뒤 `setReserved`로 선점합니다.

즉, `wait`는 “선점”을 위해 락을 반납하는 것이 맞지만,  
선점은 **“wait 중”이 아니라 `wait`에서 깨어나 락을 다시 획득한 뒤에** 결정됩니다.

## Q. A가 wait 중일 때 다른 유저가 선점하면, A는 왜 못 가져가나요?

A도 깨어난 뒤 재확인하여 가져갈 수는 있습니다.  
다만 `notifyAll()`은 여러 명을 깨우기 때문에 다음 상황이 발생할 수 있습니다.

- 취소로 좌석이 잠깐 비는 순간에  
- **락을 먼저 잡은 스레드가** 그 좌석을 먼저 가져갑니다.  
- A는 깨어났더라도 **락 경쟁에서 늦으면**, 재검사 시점에 이미 다시 예약된 상태라 실패합니다.

즉, **`wait`한 스레드에게 우선권이 부여되는 구조가 아닙니다.**  
우선권을 보장하려면 별도의 **대기열(큐)** 또는 **좌석별 조건(condition)** 설계가 필요합니다.

---

## 결론

`wait()`는 락을 반납하여 “다른 스레드가 취소/변경할 기회”를 주는 것이 맞습니다.  
그리고 좌석 선점은 “누가 먼저 락을 다시 잡고 조건을 통과하느냐”에 의해 결정됩니다.
